I"Ð+<p>Today, Iâ€™m going to talk about a paper, â€˜Learning Deep Features for Discriminative Localizationâ€™(<a href="https://arxiv.org/pdf/1512.04150.pdf">Zhou+ CVPR16</a>).
Iâ€™ll review the paper lightly first and try to implement the main functions of CAM with Pytorch, which are introduced in the paper.</p>

<h2 id="background">Background</h2>

<p>Over a long history of CNN, people made a great effort to increase the accuracy of the trained model. Since 2012, deep learning techniques have developed overwhelmingly 
and have now surpassed human beings in terms of object recognition.
However, what they had known was that filters could find the edge of an object at the shallow layers and capture the high-dimensional features as the network goes deeper.
The important thing is, they didnâ€™t know why the machine made such a judgment when it was asked to guess what the object was. 
That is to say, there was not any method that could explain the process of the machineâ€™s thinking.</p>

<p>CAM, which was developed by Bolei Zhou+ in 2016, is the very way to solve this problem. 
Using CAM, we can interpret an image from the machineâ€™s point of view and explain which part of the image was utilized to make a decision.</p>

<h2 id="introduction">Introduction</h2>

<p>Zhou showed that trained CNN model is successfully able to localize the discriminative regions of an object for classification despite no data on the location of the object
was provided.<br />
A general CNN model has a Fully-Connected layer(FC) at the last part of the network, which is used to generate the final output. To use the FC layer, however, the features 
need to be flattened while losing the spatial information that convoution layers accumulated through the previous parts of the network. This is the main reason that makes the
model lose the ability to localize objects.<br />
Besides, popular CNN models such as NIN(Network in Network) and GoogLeNet have been proposed to avoid FC layer to minimize the number of parameters while maintaining high
performance not only to keep the localization ability which is mentioned above.<br />
In order to achive this, Zhou applied GAP(global average pooling) to the model. The use of GAP prevented overfitting during training and at the same time, encouraged the
network to identify the complete extent of the object as compared to max pooling.<br />
What we have to look at is that while GAP is not a novel techinique at all, which is even simple technique with little computational cost, the unique observation that it can be
applied for accurate discriminative localizations offered a new paradigm in ML model analysis.<br />
This approach should be the core contribution of this paper and it provides us with another glimpse into the soul of CNNs.</p>

<h2 id="calss-activation-mapcam">Calss Activation Map(CAM)</h2>

<p>CAM works at the end of the network, just before the final output layer(softmax in the case of categorization). 
At this point, GAP is applied to the convolutional feature maps and the features after GAP pass through the last FC layer. 
(This network uses only one FC layer)
And then, CAM identifies the importance of the image regions by projecting back the weights of the output layer onto the convolutional feature maps.</p>

<p>let $f_k(x,y)$ represent the activation of unit $k$ in the last convolutional layer at spatial location $(x,y)$. Then, for unit $k$, the result of performing GAP is expressed
as $F^k$ and it equals to $\sum_{x, y}f_k(x,y)$. Thus for a given class c, the input to the softmax, $S_c$ is $\sum_k w_{k}^{c}F_k$, where $w_{k}^{c}$ is the weight 
corresponding to class $c$ for unit $k$. Essentially, $w_{k}^{c}$ indicates the importnace of $F_k$ for class $c$. 
To sum up, it becomes \(\begin{matrix} S_c &amp;=&amp; \sum_k w_k^c F_k \ &amp;=&amp; \sum_k w_c^k \sum_{x, y}f_k(x,y) \ &amp;=&amp; \sum_{x, y} \sum_k w_k^c f_k(x,y) \end{matrix}\) like this.
If we define $M_c$ as the CAM for class $c$, where each spatial element is given by $M_c(x, y) = \sum_k w_k^c f_k(x, y)$, we can find $S_c = \sum_{x, y} M_c(x, y)$.
Hence, $M_c(x,y)$ directly indicates the importance of the activation at spatial grid $(x,y)$ leading to the classification of an image to class c.</p>

<p>Therefore, the class activation map is simply a weighted linear sum of the presence of visual patterns at different spatial location. By simply umsampling the class activation map 
to the size of the input image, the regions of the image that are most relevant to the particular category can be identified.</p>

<p><img src="" alt="structure" class="align-center" /></p>

<h2 id="implementation">Implementation</h2>

<p>I tried to implement the main functions of the original project and visually checks their results. You can refer to <a href="https://github.com/froggydisk/CAM">here</a>.
I used Pytorch and you can simply run the code on GoogleColab.</p>

<p>I made a very simple network first and used CIFAR10 for training. 
After the training is finished, the model becomes able to classify an object and we can find the class with the highest probability.
Then, we can draw a heatmap by multiplying the corresponding weights with each feature maps of the last convolutional layer.
The code below shows the main parts of the CAM.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">feature_collection</span> <span class="o">=</span> <span class="p">[]</span> 
<span class="k">def</span> <span class="nf">get_feature</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>                                                 <span class="c1">## get features from the input
</span>  <span class="n">_</span><span class="p">,</span> <span class="n">feature</span> <span class="o">=</span> <span class="n">net</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
  <span class="n">feature_collection</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature</span><span class="p">.</span><span class="n">cpu</span><span class="p">().</span><span class="n">data</span><span class="p">.</span><span class="n">numpy</span><span class="p">())</span>

<span class="n">params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">net</span><span class="p">.</span><span class="n">parameters</span><span class="p">())</span>
<span class="n">weight_for_softmax</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">].</span><span class="n">cpu</span><span class="p">().</span><span class="n">data</span><span class="p">.</span><span class="n">numpy</span><span class="p">())</span>          <span class="c1">## get weights from the final layer
</span>
<span class="k">def</span> <span class="nf">Do_CAM</span><span class="p">(</span><span class="n">feature</span><span class="p">,</span> <span class="n">weigth_for_softmax</span><span class="p">,</span> <span class="n">class_id</span><span class="p">):</span>                      <span class="c1">## draw a heatmap
</span>  <span class="n">upsample_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">img_size</span><span class="p">,</span> <span class="n">img_size</span><span class="p">)</span>
  <span class="n">_</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">feature</span><span class="p">.</span><span class="n">shape</span>
  <span class="n">cam</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">weight_for_softmax</span><span class="p">[</span><span class="n">class_id</span><span class="p">],</span><span class="n">feature</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="o">*</span><span class="n">w</span><span class="p">))</span>    <span class="c1">## multiply the weights with the feature maps  
</span>  <span class="n">cam</span> <span class="o">=</span> <span class="n">cam</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
  <span class="n">cam</span> <span class="o">=</span> <span class="p">(</span><span class="n">cam</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="nb">min</span><span class="p">(</span><span class="n">cam</span><span class="p">))</span> 
  <span class="n">cam</span> <span class="o">=</span> <span class="n">cam</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nb">max</span><span class="p">(</span><span class="n">cam</span><span class="p">)</span>
  <span class="n">cam</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">uint8</span><span class="p">(</span><span class="mi">255</span> <span class="o">*</span> <span class="n">cam</span><span class="p">)</span>
  <span class="n">cam</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">upsample_size</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">cam</span>
</code></pre></div></div>
<p>By implementing this code, you can get a heatmap of the image you want to see.</p>

<p><strong>Settings</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dataset</span> <span class="o">=</span> <span class="s">'CIFAR10'</span>
<span class="n">img_size</span> <span class="o">=</span> <span class="mi">32</span>
<span class="n">batch_size</span> <span class="o">=</span> <span class="mi">128</span>
<span class="n">epoch</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">learning_rate</span> <span class="o">=</span> <span class="mf">0.001</span>
</code></pre></div></div>

<p>These are examples.
<img src="" alt="test1" /> <img src="" alt="cam1" /><br />
<img src="" alt="test2" /> <img src="" alt="cam2" /><br />
<img src="" alt="test3" /> <img src="" alt="cam3" /></p>

<p>However, it would be a bit hard to see the results because the size of CIFAR10 images is 32x32. 
I would recommend you to train the model with another dataset if possible, or just take a pretrained model like GoogLeNet for better results. 
If you use the pretrained model, you donâ€™t need to train it anymore. You can use it as it is.</p>

<h2 id="reference">Reference</h2>

<p><a href="https://kangbk0120.github.io/articles/2018-02/cam">https://kangbk0120.github.io/articles/2018-02/cam</a></p>
:ET